'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = it.call(o);
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

var Column = /*#__PURE__*/function (_Component) {
  _inherits(Column, _Component);

  var _super = _createSuper(Column);

  function Column() {
    _classCallCheck(this, Column);

    return _super.apply(this, arguments);
  }

  _createClass(Column, [{
    key: "render",
    value: // NOTE: Used to filter TreeTable children props
    function render() {
      return null;
    }
  }]);

  return Column;
}(React.Component);

_defineProperty(Column, "displayName", 'TreeTable.Column');

var HeaderCellWrapper = /*#__PURE__*/function (_Component) {
  _inherits(HeaderCellWrapper, _Component);

  var _super = _createSuper(HeaderCellWrapper);

  function HeaderCellWrapper() {
    _classCallCheck(this, HeaderCellWrapper);

    return _super.apply(this, arguments);
  }

  _createClass(HeaderCellWrapper, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          renderHeaderCell = _this$props.renderHeaderCell,
          grow = _this$props.grow,
          basis = _this$props.basis;
      return /*#__PURE__*/React__default["default"].createElement("div", {
        className: "cp_tree-table_header-cell",
        style: _objectSpread2(_objectSpread2({}, STYLE_COLUMN$1), {}, {
          flexGrow: grow,
          flexBasis: basis
        })
      }, renderHeaderCell());
    }
  }]);

  return HeaderCellWrapper;
}(React.Component);

_defineProperty(HeaderCellWrapper, "defaultProps", {
  grow: 1,
  basis: '0px'
});
var STYLE_COLUMN$1 = {
  boxSizing: 'border-box',
  position: 'relative',
  overflow: 'hidden',
  width: '100%'
};

var TreeTableHeader = /*#__PURE__*/function (_Component) {
  _inherits(TreeTableHeader, _Component);

  var _super = _createSuper(TreeTableHeader);

  function TreeTableHeader() {
    _classCallCheck(this, TreeTableHeader);

    return _super.apply(this, arguments);
  }

  _createClass(TreeTableHeader, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          columns = _this$props.columns,
          height = _this$props.height;
      return /*#__PURE__*/React__default["default"].createElement("div", {
        className: "cp_tree-table_header",
        style: _objectSpread2(_objectSpread2({}, STYLE_ROW$1), {}, {
          height: "".concat(height, "px")
        })
      }, columns.map(function (column, indexKey) {
        return /*#__PURE__*/React__default["default"].createElement(HeaderCellWrapper, {
          key: indexKey,
          renderHeaderCell: column.renderHeaderCell,
          grow: column.grow,
          basis: column.basis
        });
      }));
    }
  }]);

  return TreeTableHeader;
}(React.Component);

_defineProperty(TreeTableHeader, "defaultProps", {
  height: 26
});
var STYLE_ROW$1 = {
  display: 'flex',
  boxSizing: 'border-box',
  position: 'relative',
  overflow: 'hidden',
  width: '100%'
};

var CellWrapper = /*#__PURE__*/function (_Component) {
  _inherits(CellWrapper, _Component);

  var _super = _createSuper(CellWrapper);

  function CellWrapper() {
    _classCallCheck(this, CellWrapper);

    return _super.apply(this, arguments);
  }

  _createClass(CellWrapper, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          row = _this$props.row,
          renderCell = _this$props.renderCell,
          grow = _this$props.grow,
          basis = _this$props.basis;
      return /*#__PURE__*/React__default["default"].createElement("div", {
        className: "cp_tree-table_cell",
        style: _objectSpread2(_objectSpread2({}, STYLE_COLUMN), {}, {
          flexGrow: grow,
          flexBasis: basis
        })
      }, renderCell(row));
    }
  }]);

  return CellWrapper;
}(React.Component);

_defineProperty(CellWrapper, "defaultProps", {
  grow: 1,
  basis: '0px'
});
var STYLE_COLUMN = {
  boxSizing: 'border-box',
  position: 'relative',
  overflow: 'hidden',
  width: '100%'
};

// The default height (in pixels) for a row
var ROW_DEFAULT_HEIGHT = 26;

var RowModel = /*#__PURE__*/_createClass(function RowModel(data, metadata, state) {
  _classCallCheck(this, RowModel);

  _defineProperty(this, "data", void 0);

  _defineProperty(this, "metadata", void 0);

  _defineProperty(this, "$state", void 0);

  this.data = data;
  this.$state = state;
  this.metadata = metadata;
});

_defineProperty(RowModel, "DEFAULT_HEIGHT", ROW_DEFAULT_HEIGHT);

var Row = /*#__PURE__*/function (_RowModel) {
  _inherits(Row, _RowModel);

  var _super = _createSuper(Row);

  // RowAPI
  function Row(model, api) {
    var _this;

    _classCallCheck(this, Row);

    // RowModel
    _this = _super.call(this, model.data, model.metadata, model.$state); // RowAPI

    _defineProperty(_assertThisInitialized(_this), "toggleChildren", void 0);

    _defineProperty(_assertThisInitialized(_this), "updateData", void 0);

    _this.toggleChildren = api.toggleChildren;
    _this.updateData = api.updateData;
    return _this;
  }

  return _createClass(Row);
}(RowModel);

var TreeState = /*#__PURE__*/function () {
  function TreeState(data) {
    _classCallCheck(this, TreeState);

    _defineProperty(this, "data", void 0);

    _defineProperty(this, "height", void 0);

    _defineProperty(this, "hasData", void 0);

    this.data = data;
    this.hasData = data.length > 0;
    this.height = data.length == 0 ? 0 : data[data.length - 1].$state.isVisible ? data[data.length - 1].$state.top + data[data.length - 1].metadata.height : data[data.length - 1].$state.top;
  }

  _createClass(TreeState, [{
    key: "findRowModel",
    value: function findRowModel(node) {
      if (node.data == null) {
        throw new Error("Invalid TreeNode! No data property: ".concat(node, "."));
      }

      if (!this.hasData) {
        return;
      }

      for (var i = 0; i < this.data.length; i++) {
        if (this.data[i].data == node.data) {
          return this.data[i];
        }
      }

      return;
    }
  }, {
    key: "indexAtYPos",
    value: function indexAtYPos(yPos) {
      if (yPos < 0 || yPos > this.height) {
        throw new Error("Invalid y position! No row at y: ".concat(yPos, "."));
      }

      var i = 0;

      for (; i < this.data.length; i++) {
        var model = this.data[i];

        if (model.$state.isVisible && model.$state.top + model.metadata.height > yPos) {
          break;
        }
      }

      return i;
    }
  }, {
    key: "yPosAtIndex",
    value: function yPosAtIndex(index) {
      if (index < 0 || index >= this.data.length) {
        throw new Error("Invalid index! No row at index: ".concat(index, "."));
      }

      return this.data[index].$state.top;
    }
  }], [{
    key: "create",
    value: function create(data) {
      function _processNode(children, depth, index, top) {
        var isVisible = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
        var result = [];
        var _top = top;

        var _iterator = _createForOfIteratorHelper(children),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var child = _step.value;

            if (child.children != null && child.children.length > 0) {
              // hasChildren
              var childRowModel = new RowModel(child.data, {
                // Metadata
                depth: depth,
                index: index++,
                height: child.height || RowModel.DEFAULT_HEIGHT,
                hasChildren: true
              }, {
                // State
                isVisible: isVisible,
                isExpanded: false,
                top: _top
              });

              if (isVisible) {
                _top += child.height || RowModel.DEFAULT_HEIGHT;
              }

              var hasVisibleChildren = false;

              var grandchildren = _processNode(child.children, depth + 1, index, _top);

              var grandchildrenRowModels = [];

              var _iterator2 = _createForOfIteratorHelper(grandchildren),
                  _step2;

              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var grandchild = _step2.value;
                  grandchildrenRowModels.push(grandchild);
                  index++;

                  if (grandchild.$state.isVisible) {
                    hasVisibleChildren = true;
                  }
                } // Append the current child & its descendants row models

              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }

              result.push(hasVisibleChildren ? new RowModel(childRowModel.data, childRowModel.metadata, _objectSpread2(_objectSpread2({}, childRowModel.$state), {}, {
                isExpanded: true
              })) : childRowModel);
              grandchildrenRowModels.map(function (gcRowModel) {
                return result.push(gcRowModel);
              });
            } else {
              result.push(new RowModel(child.data, {
                // Metadata
                depth: depth,
                index: index++,
                height: child.height || RowModel.DEFAULT_HEIGHT,
                hasChildren: false
              }, {
                // State
                isVisible: isVisible,
                isExpanded: false,
                top: _top
              }));

              if (isVisible) {
                _top += child.height || RowModel.DEFAULT_HEIGHT;
              }
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return result;
      }

      var rowModels = _processNode(data, 0, 0, 0, true);

      return new TreeState(rowModels);
    }
  }, {
    key: "createEmpty",
    value: function createEmpty() {
      return new TreeState([]);
    }
  }, {
    key: "sliceRows",
    value: function sliceRows(source, from, to) {
      if (from < 0) {
        throw new Error("Invalid range: from < 0 (".concat(from, " < 0)."));
      }

      if (from > source.data.length) {
        throw new Error("Invalid range: from > max size (".concat(from, " > ").concat(source.data.length, ")."));
      }

      if (to > source.data.length) {
        throw new Error("Invalid range: to > max size (".concat(to, " > ").concat(source.data.length, ")."));
      }

      if (from > to) {
        throw new Error("Invalid range: from > to (".concat(from, " > ").concat(to, ")."));
      }

      return source.data.slice(from, to);
    }
  }, {
    key: "_hideRowsInRange",
    value: function _hideRowsInRange(source) {
      var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : source.data.length;
      var startRange = TreeState.sliceRows(source, 0, from);
      var _top = source.data[from].$state.top;
      var updatedRange = TreeState.sliceRows(source, from, to).map(function (model) {
        if (model.metadata.depth > 0 && model.$state.isVisible) {
          model.$state.isVisible = false;
        }

        model.$state.isExpanded = false;
        model.$state.top = _top;

        if (model.$state.isVisible) {
          _top += model.metadata.height;
        }

        return model;
      });
      var endRange = TreeState.sliceRows(source, to, source.data.length).map(function (model) {
        model.$state.top = _top;

        if (model.$state.isVisible) {
          _top += model.metadata.height;
        }

        return model;
      }); // Update $state.isExpanded for rows before the from↔to range

      if (startRange.length > 0 && updatedRange.length > 0) {
        if (startRange[startRange.length - 1].metadata.depth < updatedRange[0].metadata.depth) {
          startRange[startRange.length - 1].$state.isExpanded = false;
        }
      }

      return new TreeState(startRange.concat(updatedRange, endRange));
    }
  }, {
    key: "_showRowsInRange",
    value: function _showRowsInRange(source) {
      var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : source.data.length;
      var depthLimit = arguments.length > 3 ? arguments[3] : undefined;
      var startRange = TreeState.sliceRows(source, 0, from);
      var _top = source.data[from].$state.top;
      var updatedRange = TreeState.sliceRows(source, from, to).map(function (model, i) {
        if (model.metadata.depth > 0 && !model.$state.isVisible) {
          // If a depthLimit value is set, only show nodes with a depth value less or equal
          if (depthLimit == null || depthLimit != null && model.metadata.depth <= depthLimit) {
            model.$state.isVisible = true;
          }
        }

        model.$state.top = _top;

        if (model.$state.isVisible) {
          _top += model.metadata.height;

          if (model.metadata.hasChildren) {
            // Peek at the next row, if depth > currentDepth & it will be toggled to be visible,
            // $state.isExpanded on the current row will be set to true
            if (from + i + 1 < to) {
              var nextRowModel = source.data[from + i + 1];

              if (nextRowModel.metadata.depth > model.metadata.depth && depthLimit == null || depthLimit != null && nextRowModel.metadata.depth <= depthLimit) {
                model.$state.isExpanded = true;
              }
            }
          }
        }

        return model;
      });
      var endRange = TreeState.sliceRows(source, to, source.data.length).map(function (model) {
        model.$state.top = _top;

        if (model.$state.isVisible) {
          _top += model.metadata.height;
        }

        return model;
      }); // Update $state.isExpanded for rows before the from↔to range

      if (startRange.length > 0 && updatedRange.length > 0) {
        if (startRange[startRange.length - 1].metadata.hasChildren && startRange[startRange.length - 1].metadata.depth < updatedRange[0].metadata.depth) {
          startRange[startRange.length - 1].$state.isExpanded = true;
        }
      }

      return new TreeState(startRange.concat(updatedRange, endRange));
    }
  }, {
    key: "expandAll",
    value: function expandAll(source, depthLimit) {
      return TreeState._showRowsInRange(source, undefined, undefined, depthLimit);
    }
  }, {
    key: "collapseAll",
    value: function collapseAll(source) {
      return TreeState._hideRowsInRange(source);
    }
  }, {
    key: "expandAncestors",
    value: function expandAncestors(source, model) {
      if (!source.hasData) {
        return TreeState.createEmpty();
      }

      if (model.$state.isVisible || model.metadata.depth == 0 || model.metadata.index == 0) {
        return new TreeState(source.data.slice());
      } // Find range start


      var startIndex = model.metadata.index - 1;

      for (; startIndex >= 0; startIndex--) {
        var currentRowModel = source.data[startIndex];

        if (currentRowModel.metadata.depth == 0) {
          break;
        }
      } // Find range end (the end of the current root node)


      var endIndex = model.metadata.index;

      for (; endIndex < source.data.length; endIndex++) {
        var _currentRowModel = source.data[endIndex];

        if (_currentRowModel.metadata.depth === 0) {
          break;
        }
      }

      return TreeState._showRowsInRange(source, startIndex, endIndex);
    }
  }, {
    key: "toggleChildren",
    value: function toggleChildren(source, model) {
      if (model.metadata.index == source.data.length - 1 // Last item, no children available
      || model.metadata.hasChildren == false) {
        return new TreeState(source.data.slice());
      }

      var currentDepth = model.metadata.depth;
      var shouldToggleOpen = null;
      var lastChildIndex = model.metadata.index + 1;

      for (; lastChildIndex < source.data.length; lastChildIndex++) {
        var currentRow = source.data[lastChildIndex];

        if (currentRow.metadata.depth < currentDepth + 1) {
          break;
        }

        if (shouldToggleOpen == null) {
          shouldToggleOpen = !currentRow.$state.isVisible;
        }
      }

      return shouldToggleOpen ? TreeState._showRowsInRange(source, model.metadata.index + 1, lastChildIndex, currentDepth + 1) : TreeState._hideRowsInRange(source, model.metadata.index + 1, lastChildIndex);
    }
  }, {
    key: "updateData",
    value: function updateData(source, model, newData) {
      var startRange = TreeState.sliceRows(source, 0, model.metadata.index);
      var updatedRange = [new RowModel(newData, model.metadata, model.$state)];
      var endRange = TreeState.sliceRows(source, model.metadata.index + 1, source.data.length);
      return new TreeState(startRange.concat(updatedRange, endRange));
    }
  }]);

  return TreeState;
}();

var createRow = function createRow(model, source, onChangeCb) {
  var rowAPI = {
    toggleChildren: function toggleChildren() {
      var nextState = TreeState.toggleChildren(source, model);
      onChangeCb(nextState);
    },
    updateData: function updateData(newData) {
      var nextState = TreeState.updateData(source, model, newData);
      onChangeCb(nextState);
    }
  };
  return new Row(model, rowAPI);
};

var VirtualListRow = /*#__PURE__*/function (_Component) {
  _inherits(VirtualListRow, _Component);

  var _super = _createSuper(VirtualListRow);

  function VirtualListRow() {
    var _this;

    _classCallCheck(this, VirtualListRow);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "handleChange", function (value) {
      var onChange = _this.props.onChange;
      onChange(value);
    });

    return _this;
  }

  _createClass(VirtualListRow, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          model = _this$props.model,
          columns = _this$props.columns,
          data = _this$props.data,
          index = _this$props.index,
          relIndex = _this$props.relIndex;
      var row = createRow(model, data, this.handleChange);
      return /*#__PURE__*/React__default["default"].createElement("div", {
        className: "cp_tree-table_row",
        style: _objectSpread2(_objectSpread2({}, STYLE_ROW), {}, {
          height: "".concat(row.metadata.height, "px")
        }),
        "data-index": index,
        "data-relindex": relIndex
      }, columns.map(function (column, indexKey) {
        return /*#__PURE__*/React__default["default"].createElement(CellWrapper, {
          key: indexKey,
          row: row,
          renderCell: column.renderCell,
          grow: column.grow,
          basis: column.basis
        });
      }));
    }
  }]);

  return VirtualListRow;
}(React.Component);
var STYLE_ROW = {
  display: 'flex',
  boxSizing: 'border-box',
  position: 'relative',
  overflow: 'hidden',
  width: '100%'
};

var VirtualList = /*#__PURE__*/function (_Component) {
  _inherits(VirtualList, _Component);

  var _super = _createSuper(VirtualList);

  function VirtualList() {
    var _this;

    _classCallCheck(this, VirtualList);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "state", {
      topOffset: 0,
      overscanHeight: 100
    });

    _defineProperty(_assertThisInitialized(_this), "containerRef", /*#__PURE__*/React.createRef());

    _defineProperty(_assertThisInitialized(_this), "handleScroll", function () {
      if (_this.containerRef.current != null) {
        var _scrollTop = _this.containerRef.current.scrollTop;
        var onScroll = _this.props.onScroll;
        onScroll(_scrollTop);

        _this.setState({
          topOffset: _scrollTop
        });
      }
    });

    _defineProperty(_assertThisInitialized(_this), "scrollTo", function (posY) {
      if (_this.containerRef.current != null) {
        _this.containerRef.current.scrollTop = posY;
      }
    });

    return _this;
  }

  _createClass(VirtualList, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          data = _this$props.data,
          columns = _this$props.columns,
          height = _this$props.height,
          onChange = _this$props.onChange;
      var _this$state = this.state,
          topOffset = _this$state.topOffset,
          overscanHeight = _this$state.overscanHeight;
      var startYMax = Math.max(0, data.height - height - overscanHeight * 2);
      var startY = Math.min(startYMax, Math.max(0, topOffset - overscanHeight));
      var startIndex = data.indexAtYPos(startY);
      var endY = Math.min(data.height, topOffset + height + overscanHeight);
      var endIndex = data.indexAtYPos(endY);
      var contentTopOffset = data.yPosAtIndex(startIndex);
      var visibleRowsData = [];
      TreeState.sliceRows(data, startIndex, endIndex).forEach(function (rowModel) {
        if (rowModel.$state.isVisible) {
          visibleRowsData.push(rowModel);
        }
      });
      var visibleVLRows = visibleRowsData.map(function (rowModel, relIndex) {
        return /*#__PURE__*/React__default["default"].createElement(VirtualListRow, {
          key: relIndex,
          data: data,
          model: rowModel,
          columns: columns,
          onChange: onChange,
          index: rowModel.metadata.index,
          relIndex: relIndex
        });
      });
      return /*#__PURE__*/React__default["default"].createElement("div", {
        className: "cp_tree-table_viewport",
        style: _objectSpread2(_objectSpread2({}, STYLE_LIST), {}, {
          height: "".concat(height, "px")
        }),
        ref: this.containerRef,
        onScroll: this.handleScroll
      }, /*#__PURE__*/React__default["default"].createElement("div", {
        style: _objectSpread2(_objectSpread2({}, STYLE_WRAPPER), {}, {
          height: "".concat(data.height, "px")
        })
      }, /*#__PURE__*/React__default["default"].createElement("div", {
        style: _objectSpread2(_objectSpread2({}, STYLE_CONTENT), {}, {
          top: "".concat(contentTopOffset, "px")
        }),
        className: "cp_tree-table_mover"
      }, visibleVLRows)));
    }
  }]);

  return VirtualList;
}(React.Component);
var STYLE_LIST = {
  overflow: 'auto',
  WebkitOverflowScrolling: 'touch'
};
var STYLE_WRAPPER = {
  position: 'relative',
  overflow: 'hidden',
  width: '100%',
  minHeight: '100%'
};
var STYLE_CONTENT = {
  position: 'absolute',
  overflow: 'visible',
  height: '100%',
  width: '100%',
  top: '0px',
  left: '0px'
};

var TABLE_DEFAULT_HEIGHT = 260;

var noopOnChange = function noopOnChange(value) {};

var noopOnScroll = function noopOnScroll(scrollTop) {};

var TreeTable = /*#__PURE__*/function (_Component) {
  _inherits(TreeTable, _Component);

  var _super = _createSuper(TreeTable);

  function TreeTable() {
    var _this;

    _classCallCheck(this, TreeTable);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "vListRef", /*#__PURE__*/React.createRef());

    _defineProperty(_assertThisInitialized(_this), "handleChange", function (value) {
      var onChange = _this.props.onChange;
      (onChange || noopOnChange)(value);
    });

    return _this;
  }

  _createClass(TreeTable, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          value = _this$props.value,
          children = _this$props.children,
          onScroll = _this$props.onScroll,
          height = _this$props.height,
          headerHeight = _this$props.headerHeight,
          className = _this$props.className;
      var columnsDef = [];
      React.Children.toArray(children).forEach(function (node) {
        if (isColumnElement(node)) {
          columnsDef.push(node.props);
        }
      });
      return /*#__PURE__*/React__default["default"].createElement("div", {
        className: "cp_tree-table ".concat(className != null && className)
      }, /*#__PURE__*/React__default["default"].createElement(TreeTableHeader, {
        columns: columnsDef,
        height: headerHeight
      }), value.hasData && /*#__PURE__*/React__default["default"].createElement(VirtualList, {
        data: value,
        columns: columnsDef,
        height: Number(height) || TABLE_DEFAULT_HEIGHT,
        onChange: this.handleChange,
        ref: this.vListRef,
        onScroll: onScroll || noopOnScroll
      }));
    }
  }, {
    key: "scrollTo",
    value: // Public API
    function scrollTo(posY) {
      if (this.vListRef.current != null) {
        this.vListRef.current.scrollTo(posY);
      }
    }
  }]);

  return TreeTable;
}(React.Component);

_defineProperty(TreeTable, "Column", Column);

function isColumnElement(elem) {
  return checkElementType(elem, Column);
}

function checkElementType(elem, cmpType) {
  return elem != null && elem.type != null && elem.type.displayName != null && elem.type.displayName === cmpType.displayName;
}

exports.Row = Row;
exports.RowModel = RowModel;
exports.TreeState = TreeState;
exports.TreeTable = TreeTable;
